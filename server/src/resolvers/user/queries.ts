import { mapRole } from "../../types";
import { getRepository } from "typeorm";
import { User } from "../../entities/User";
import { notFound, notLoggedIn } from "../graphql-response/ErrorFunctions";
import { UserProject } from "../graphql-response/Objects";
import {
  UserOverviewResponse,
  UserProjectResponse,
} from "../graphql-response/Response";

/**
 * Retrieves a User from the Database using the session key generated by Express.
 * If null, the User is not signed in.
 *
 * @param id the requested session ID from the client.
 * @returns {Promise<User | null>}
 */
export const userQuery = async (id: number | null): Promise<User | null> => {
  if (!id) return null;
  const user = await getRepository(User).findOne({ id });

  return user || null;
};

/**
 * Retrieves metrics & feed for a User.
 * Metrics are counted via SQL. Feed is returned from database.
 *
 * @param limit how many items are being returned.
 * @param id the requested session ID from the client.
 * @param cursor optional cursor for pagiation
 * @returns {Promise<UserOverviewResponse>} a paginated response
 */
export const overviewQuery = async (
  limit: number,
  id: number | null,
  cursor?: string
): Promise<UserOverviewResponse> => {
  if (!id) return notLoggedIn();

  const edge = limit + 1; // check if we have more data

  // Starter query
  const query = getRepository(User)
    .createQueryBuilder("user")
    .loadRelationCountAndMap("user.project", "user.projectManagement")
    .loadRelationCountAndMap("user.created", "user.issues")
    .loadRelationCountAndMap("user.posted", "user.comments")
    .loadRelationCountAndMap("user.owned", "user.ownedProjects")
    .leftJoinAndSelect("user.feed", "feed")
    .where("user.id = :userId", { userId: id });

  // If paginating, do so.
  if (cursor)
    query.andWhere("feed.createdAt < :cursor", { cursor: new Date(cursor) });

  // Finish query
  const user = await query
    .orderBy("feed.createdAt", "DESC")
    .limit(edge)
    .getOne();

  if (!user) return notFound("user");

  // since we add new types to User that Typescript
  // can't detect we cast as any.
  const temp = user as any;

  return {
    hasMore: user.feed.length === edge,
    response: {
      projects: temp.project,
      feed: user.feed.slice(0, limit),
      owned: temp.owned,
      posted: temp.posted,
      created: temp.created,
    },
  };
};

/**
 * Get Users based on a search query.
 *
 * @param query the search query
 * @param limit the amount of users returned
 * @returns {Promise<User[]>}
 */
export const usersQuery = async (
  query: string,
  limit: number
): Promise<User[]> => {
  // Not paginated because the query
  // is unique so the User just has to be more specific.

  const partialQuery = getRepository(User)
    .createQueryBuilder("user")
    .select()
    .where("email ILIKE :query", { query: `${query}%` });

  return await partialQuery
    .orderBy("user.createdAt", "DESC")
    .limit(limit)
    .getMany();
};

/**
 * Generates the requested User's projects in table format
 *
 * @param id the requested session ID from the client.
 * @param cursor the optional cursor for pagination
 * @returns {Promise<UserProjectResponse>}
 */
export const userProjectsQuery = async (
  id: number | null,
  cursor?: string
): Promise<UserProjectResponse> => {
  // 1. Join the required tables 2. Select fields & count
  // 3. Since we used COUNT, we need GROUP BY

  const query = getRepository(User)
    .createQueryBuilder("user")
    .leftJoin("user.projectManagement", "projectManagement")
    .leftJoin("projectManagement.project", "project")
    .leftJoin("project.owner", "owner")
    .leftJoin("project.issues", "issues")
    .select([
      "project.id",
      "project.name",
      "projectManagement.role",
      "projectManagement.createdAt",
      "owner.name",
    ])
    .addSelect("COUNT(issues)", "count")
    .groupBy("project.id")
    .addGroupBy("projectManagement.createdAt")
    .addGroupBy("projectManagement.role")
    .addGroupBy("project.name")
    .addGroupBy("owner.name")
    .where("user.id = :id", { id });

  // Paginate
  if (cursor)
    query.andWhere("projectManagement.createdAt < :cursor", {
      cursor: new Date(Date.now()),
    });

  const user = await query
    .orderBy("projectManagement.createdAt", "DESC")
    .limit(5)
    .getRawMany();

  if (!user) return notLoggedIn();

  // Format for table
  const result: UserProject[] = user.map((user) => {
    return {
      name: user.project_name,
      createdAt: new Date(user.projectManagement_createdAt).toDateString(),
      issues: parseFloat(user.count),
      owner: user.owner_name,
      role: mapRole(parseFloat(user.projectManagement_role)),
      id: user.project_id,
    };
  });

  return {
    response: result,
  };
};

/**
 * Returns the User's role.
 * Determines whether or not a User has permission to edit a Project
 *
 * @param id the ID of the project
 * @param userId the requested ID of the User
 * @returns {Promise<Role>}
 */
export const editQuery = async (id: number, userId: number | null) => {
  if (!userId) throw new Error();

  const user = await getRepository(User)
    .createQueryBuilder("user")
    .leftJoinAndSelect("user.projectManagement", "projectManagement")
    .where("user.id = :userId", { userId })
    .andWhere("projectManagement.project.id = :id", { id })
    .getOne();

  if (!user) throw new Error();
  if (!user.projectManagement || user.projectManagement.length === 0)
    throw new Error();

  return user.projectManagement[0].role;
};
